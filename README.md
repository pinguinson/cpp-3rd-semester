## Репозиторий с домашними заданиями по C++

- [x] BigInteger
- [ ] Poker
- [ ] DFS
- [ ] Chat

## Подробное описание заданий

#### BigInteger

Реализовать класс BigInteger, который (звездочками отмечены необязательные пункты):
- [x] Имеет конcтруктор по умолчанию, создающий объект равный нулю
- [x] Имеет конструктор от int
- [x] * Имеет конструктор от std::string
- [x] * Может быть приведен к std::string
- [x] Имеет конструктор копирования
- [x] Имеет оператор присваивания
- [x] Поддерживает операторы +, -, *
- [x] Поддерживает операторы +=, -=, *=
- [ ] * Поддерживает операторы /, %, /=, %=
- [ ] * Имеет move-конструктор
- [x] Может быть прочитан из потока (std::istream)
- [x] Может быть выведен в поток (std::ostream)
- [x] Конструктор от std::string и оператор чтения из потока бросают адекватные исключения при ошибках

---------------

#### Poker

Задание - написать приложение для игры в покер нескольких игроков на одном компьютере. Интерфейс произвольный, вполне достаточно консольного вида вопрос-ответ. Правила пятикарточного покера тут.

- [ ] Следует придерживаться парадигм ООП
- [ ] Карты бывают открытыми и закрытыми, очевидно, что открытая карта может стать закрытой, но никогда наоборот (при этом, как подсказывает здравый смысл, карта может быть открыта только для одного игрока)
- [ ] Класс игрок-человек должен быть реализацией некоторого абстрактного класса Игрок, для которого должна быть возможность подставить реализацию компьютерного игрока.
- [ ] Для компьютерного игрока не должно быть возможности жульничать, причем создание новых, уничтожение существующих или изменение карт должны приводить к ошибкам при компиляции
- [ ] * Корректная обработка любого некорректного ввода пользователя
- [ ] * Покрытие кода тестами с использованием любого unittest фреймворка
- [ ] * Универсальная реализация (конкретные правила игры - реализация некоторого абстрактного класса)

---------------

#### DFS

Реализовать представление графа с реализацией dfs:

    template<typename NodePayload>
    class Graph {
    public:
      typedef /*type of your choise*/ NodeHandle;
      typedef /*type of your chois*/ EdgeHandle;
      typedef std::function<void(NodeHandle const &)> NodeVisitor;
      typedef std::function<void(NodeHandle const &)> EdgeVisitor;
    public:
      Graph();
      ~Graph();
      void loadFromFile(std::string const & filename);
      void saveToFile(std::string const & filename);
      NodeHandle addNode();
      void addEdge(NodeHandle const & a, NodeHandle const & b);
      void forEachNode(std::function<void(NodeHandle const &)> const & visitor) const;
      size_t getNodesCount() const;
      void forEachEdge(NodeHandle const & source, EdgeVsitor const & visitor);
      NodeHandle move(NodeHandle const & origin, EdgeHandle const & edge);
      NodePayload & operator[](NodeHandle const & node);
      void dfs(NodeVisitor const & startNode, NodeVisitor const & endNode, NodeVisitor const & discoverNode);
    };

Вы можете заменить std::function на абстрактные классы(для dfs все три вызова - методы одного класса с такими же именами, как параметры предложенного метода, у остальных - оператор () с соотвествующим аргументом).
Решение не должно содержать рекурсивных вызовов.
Бонусные баллы будут даваться за скорость работы приложения.

---------------

#### Chat

Реализовать чат:
- [ ] Графический интерфейс с использованием Qt
- [ ] Передача сообщений по UDP (broadcast)
- [ ] Возможность указать имя пользователя
- [ ] Отображение списка всех польователей, который писали сообщения с момента запуска приложения
- [ ] В окне сообщений также отображаются имена пользователей (перед сообщениями)
- [ ] * Интерфейс на QML
- [ ] * Отображать имена всех доступых пользователей вне зависимости от того, писали они в чат или нет
